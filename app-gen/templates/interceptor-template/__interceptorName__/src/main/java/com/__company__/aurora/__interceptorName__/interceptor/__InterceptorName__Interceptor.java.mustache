package {{chenilePackage}}.{{interceptorName}}.interceptor;

import java.util.Map;
import org.chenile.core.context.ChenileExchange;
import org.chenile.core.interceptors.BaseChenileInterceptor;

import {{chenilePackage}}.{{interceptorName}}.{{InterceptorName}};

/**
 * 
 * A custom interceptor. 
 * This uses a customized annotation that contains all the configurtion required
 *
 */
public class {{InterceptorName}}Interceptor extends BaseChenileInterceptor {

	@Override
	protected void doPreProcessing(ChenileExchange exchange) {
		Map<String,Object> config = getExtensionByAnnotation("{{InterceptorName}}", exchange);
		// do something with the config 
		// use exchange.getBody() to access the payload if this interceptor is intended to be a payload processor
		// else use exchange.getHeader("name") to access specific headers
	}

	@Override
	protected void doPostProcessing(ChenileExchange exchange) {
		Map<String,Object> config = getExtensionByAnnotation("{{InterceptorName}}", exchange);
		// do something with the config 
		// use exchange.getResponse() to access the response
		// use exchange.getException() to access the response
	}	

	// Use this method to bypass the interceptor if there exists no configuration
	@Override
	protected boolean bypassInterception(ChenileExchange exchange) {
		Map<String,Object> config = getExtensionByAnnotation("{{InterceptorName}}", exchange);
		if(config == null)return true;
		return false;
	}
}
